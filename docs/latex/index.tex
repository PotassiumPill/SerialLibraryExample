\label{index_md_SerialLibraryExample_serial_controllers_README}%
\Hypertarget{index_md_SerialLibraryExample_serial_controllers_README}%
 Library for serial communication in C++ using various APIs and hardware for use in Microchip Studio projects.\hypertarget{index_autotoc_md1}{}\doxysection{Current APIs\+:}\label{index_autotoc_md1}
1) Serial UART~\newline
 2) Serial USB (CDC) using tinyusb~\newline
 3) Serial SPI~\newline
\hypertarget{index_autotoc_md2}{}\doxysection{Current Hardware\+:}\label{index_autotoc_md2}
1) SAMD21 Series ARM Microcontroller\hypertarget{index_autotoc_md3}{}\doxysection{How To Use\+:}\label{index_autotoc_md3}
1) Setup project for desired hardware.~\newline
 2) In your C and C++ compilers, add ../serial\+\_\+controllers to the include path.~\newline
 3) Open \mbox{\hyperlink{serial__comm__config_8h_source}{serial\+\_\+comm\+\_\+config.\+h}}, and define the SERCOM\+\_\+\+MCU\+\_\+\+OPT macro to your desired hardware (refer to \mbox{\hyperlink{serial__comm__options_8h_source}{serial\+\_\+comm\+\_\+options.\+h}} for all defined hardware).~\newline
 4) Define the SERCOM\+\_\+\+MODULE\+\_\+\+OPT as all desired protocols for your project (OPT\+\_\+\+SERCOM\+\_\+\+UART $\vert$ OPT\+\_\+\+SERCOM\+\_\+\+SPI $\vert$ OPT\+\_\+\+SERCOM\+\_\+\+USB defines all protocols).~\newline
 5) include \mbox{\hyperlink{serial__communication_8h_source}{serial\+\_\+communication.\+h}} in your project to use serial protocols.~\newline
 6) Initialize harware clocks.~\newline
 7) Initialize and implement all ISRs to ensure proper functionality!~\newline
\hypertarget{index_autotoc_md4}{}\doxysection{Serial USB Code Setup Example\+:}\label{index_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{\#include "{}serial\_communication.h"{}}
\DoxyCodeLine{...}
\DoxyCodeLine{char usb\_buf[USB\_DEFAULT\_FIFO\_SIZE];            //call outside of function calls so variable stays active}
\DoxyCodeLine{SerialUSB::USBController usb\_controller;}
\DoxyCodeLine{...}
\DoxyCodeLine{usb\_controller.Init(usb\_buf, sizeof(usb\_buf));      //call after clock setup (this will set clock to 48 MHz)}
\DoxyCodeLine{usb\_controller.Task();                      //must be called often, preferrably inside of any smaller loop or blocking function}
\DoxyCodeLine{...}
\DoxyCodeLine{void USB\_Handler()                      //use the proper ISR Handler according to your hardware!}
\DoxyCodeLine{\{}
\DoxyCodeLine{    usb\_controller.ISR();   }
\DoxyCodeLine{\}}

\end{DoxyCode}


{\itshape NOTE\+: Call USBController.\+Task() in every loop in your main program so USB communication works. USBController.\+Task() can also be used to flash received data onto serial terminal by passing true into Task parameters.}\hypertarget{index_autotoc_md5}{}\doxysubsection{USB Descriptors for compatibility in host applications\+:}\label{index_autotoc_md5}

\begin{DoxyItemize}
\item VID\+: 0x\+Cafe
\item PID\+: 0x4001
\item BCD\+: 0x0200
\end{DoxyItemize}\hypertarget{index_autotoc_md6}{}\doxysection{Serial UART Code Setup Example\+:}\label{index_autotoc_md6}

\begin{DoxyCode}{0}
\DoxyCodeLine{\#include "{}serial\_communication.h"{}}
\DoxyCodeLine{...}
\DoxyCodeLine{char rx\_buf[DEFAULT\_RX\_BUFFER\_SIZE];}
\DoxyCodeLine{char tx\_buf[DEFAULT\_TX\_BUFFER\_SIZE];}
\DoxyCodeLine{SerialUART::UARTController uart\_controller;}
\DoxyCodeLine{...}
\DoxyCodeLine{UARTHAL::Peripheral uart\_peripheral;}
\DoxyCodeLine{UARTHAL::GetPeripheralDefaults(\&uart\_peripheral);                               //Can also call hardware specific peripheral initalizing functions or manually initialize peripheral }
\DoxyCodeLine{uart\_controller.Init(\&uart\_peripheral, tx\_buf, sizeof(tx\_buf), rx\_buf, sizeof(rx\_buf));     //call after clock setup}
\DoxyCodeLine{uart\_controller.EnableErrorIRQ();                                           //optional IRQ setups}
\DoxyCodeLine{...}
\DoxyCodeLine{void SERCOM0\_Handler()                                                  //use the proper ISR Handler according to your hardware!}
\DoxyCodeLine{\{}
\DoxyCodeLine{    uart\_controller.ISR();}
\DoxyCodeLine{    //uart\_controller.EchoRx();                                         //call EchoRx() to debug by flashing all received characters onto terminal, exclude for actual use}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{index_autotoc_md7}{}\doxysection{Serial SPI Code Setup Example\+:}\label{index_autotoc_md7}

\begin{DoxyCode}{0}
\DoxyCodeLine{\#include "{}serial\_communication.h"{}}
\DoxyCodeLine{...}
\DoxyCodeLine{char miso\_buf[DEFAULT\_MISO\_BUFFER\_SIZE];}
\DoxyCodeLine{char mosi\_buf[DEFAULT\_MOSI\_BUFFER\_SIZE];}
\DoxyCodeLine{SerialSPI::SPIController spi\_controller;}
\DoxyCodeLine{...}
\DoxyCodeLine{SPIHAL::Peripheral spi\_peripheral;}
\DoxyCodeLine{SPIHAL::GetPeripheralDefaults(\&spi\_peripheral);                                     //Can also call hardware specific peripheral initalizing functions or manually initialize peripheral }
\DoxyCodeLine{spi\_controller.Init(\&spi\_peripheral, mosi\_buf, sizeof(mosi\_buf), miso\_buf, sizeof(miso\_buf));       //call after clock setup}
\DoxyCodeLine{spi\_controller.EnableErrorIRQ();                                                //optional IRQ setups}
\DoxyCodeLine{...}
\DoxyCodeLine{void SERCOM4\_Handler()                                                      //use the proper ISR Handler according to your hardware!}
\DoxyCodeLine{\{}
\DoxyCodeLine{    spi\_controller.ISR();}
\DoxyCodeLine{    //spi\_controller.EchoMISO();                                                //call EchoMISO() to debug by flashing all received characters onto terminal, exclude for actual use}
\DoxyCodeLine{\}}

\end{DoxyCode}


{\itshape NOTE\+: you will primarily call SPIController.\+SPIHost\+Procedure() when transmitting opcodes to SPI client, refer to doxygen docs to learn more about its usage.} 