\hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller}{}\doxysection{Serial\+UART\+::UARTController Class Reference}
\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller}\index{SerialUART::UARTController@{SerialUART::UARTController}}


UART serial communication controller object  




{\ttfamily \#include $<$serial\+\_\+uart.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af85abfd70eb695772bb00fbf3e794b70}{UARTController}} (void)
\begin{DoxyCompactList}\small\item\em Constructor. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6af0ef220033acccc163141be0223200}{$\sim$\+UARTController}} (void)
\begin{DoxyCompactList}\small\item\em Destructor. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init}} (\mbox{\hyperlink{struct_u_a_r_t_h_a_l_1_1_peripheral}{UARTHAL\+::\+Peripheral}} $\ast$p\+\_\+config, char $\ast$tx\+\_\+buf, uint32\+\_\+t tx\+\_\+size, char $\ast$rx\+\_\+buf, uint32\+\_\+t rx\+\_\+size)
\begin{DoxyCompactList}\small\item\em Initializes UART serial communication. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}{Deinit}} (void)
\begin{DoxyCompactList}\small\item\em Disables and resets UART serial communication. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab23205f9716835204b376bd6326a0aae}{Reset\+TXBuffer}} (char $\ast$tx\+\_\+buf, uint32\+\_\+t tx\+\_\+size)
\begin{DoxyCompactList}\small\item\em Resets transmit buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a7fc563163f811d74b8f901a1d0c3d302}{Reset\+RXBuffer}} (char $\ast$rx\+\_\+buf, uint32\+\_\+t rx\+\_\+size)
\begin{DoxyCompactList}\small\item\em Resets receive buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6e154b891bf847e222fd3509910a1acb}{Clear\+Buffers}} (bool clear\+\_\+tx=true, bool clear\+\_\+rx=true)
\begin{DoxyCompactList}\small\item\em Clears Rx and/or Tx buffers. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a92e007bfb65edacf4a77e38c0d90c00a}{ISR}} (void)
\begin{DoxyCompactList}\small\item\em Interrupt Service Routine. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}{Transmit}} (char input)
\begin{DoxyCompactList}\small\item\em Transmit character into logic layer transmit buffer to be sent to USART data buffer. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}{Receive}} (char $\ast$output=nullptr)
\begin{DoxyCompactList}\small\item\em Receive character from logic layer receive buffer and free buffer space. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_acc003e020b56fc1c8a6c4a9433ebe2d9}{Transmit\+Packet}} (const char $\ast$input, uint32\+\_\+t num\+\_\+bytes)
\begin{DoxyCompactList}\small\item\em Transmits a packet of bytes, which do not need to be null-\/terminated. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a63d71a7be771a2c8d435af6853df1e84}{Transmit\+String}} (const char $\ast$input)
\begin{DoxyCompactList}\small\item\em Transmit an entire char array at once. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_aa6127de65b6715caf5171630fc7c0b09}{Echo\+Rx}} (void)
\begin{DoxyCompactList}\small\item\em Transmits char from the receive buffer. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}{Receive\+String}} (const char $\ast$input, uint32\+\_\+t shift=0u, bool move\+\_\+pointer=true)
\begin{DoxyCompactList}\small\item\em Checks if input string has been received from USART. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923}{Transmit\+Int}} (uint32\+\_\+t input)
\begin{DoxyCompactList}\small\item\em Transmits unsigned int as ASCII string. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be}{Receive\+Int}} (uint32\+\_\+t $\ast$output)
\begin{DoxyCompactList}\small\item\em Receives ASCII number and outputs unsigned int. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14}{Receive\+Param}} (uint32\+\_\+t $\ast$output, const char $\ast$input, char delimiter=\textquotesingle{}\textbackslash{}0\textquotesingle{}, uint8\+\_\+t max\+\_\+digits=8u)
\begin{DoxyCompactList}\small\item\em Checks if input string followed by an ASCII parameter has been received from USART and returns the ASCII parameter as unsigned int. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad02249a538a10900220e0c931539b522}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad02249a538a10900220e0c931539b522}} 
uint32\+\_\+t {\bfseries Get\+RXAvailable} (void) const
\begin{DoxyCompactList}\small\item\em Getter for number of unread characters available in receive buffer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a3cf25f02fb1caef9c7d9658f3291b229}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a3cf25f02fb1caef9c7d9658f3291b229}} 
uint32\+\_\+t {\bfseries Get\+TXEmpty} (void) const
\begin{DoxyCompactList}\small\item\em Getter for number of empty slots available in transmit buffer. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a24ef04344f178245dd830de10dc30877}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a24ef04344f178245dd830de10dc30877}} 
\mbox{\hyperlink{struct_serial_u_a_r_t_1_1_buffer_states}{Buffer\+States}} {\bfseries Get\+Buffer\+States} (void) const
\begin{DoxyCompactList}\small\item\em Get receive and transmit buffer states. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_serial_u_a_r_t_1_1_status}{Status}} \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a0981486823056dda314018359b9159af}{Get\+Status}} (void) const
\begin{DoxyCompactList}\small\item\em Getter for errors, interrupts, and power state. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a64dcc4207f50cbe72a0faf5085223a42}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a64dcc4207f50cbe72a0faf5085223a42}} 
void {\bfseries Clear\+TXInterrupt} (void)
\begin{DoxyCompactList}\small\item\em Clears TX Interrupt \mbox{\hyperlink{struct_serial_u_a_r_t_1_1_status}{Status}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ac3399e6c6eaed563b8c474533e49f205}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ac3399e6c6eaed563b8c474533e49f205}} 
void {\bfseries Clear\+RXInterrupt} (void)
\begin{DoxyCompactList}\small\item\em Clears RX Interrupt \mbox{\hyperlink{struct_serial_u_a_r_t_1_1_status}{Status}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a84312b3ecd69219152e3fdc239b1cfba}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a84312b3ecd69219152e3fdc239b1cfba}} 
void {\bfseries Clear\+Errors} (void)
\begin{DoxyCompactList}\small\item\em Clears Error \mbox{\hyperlink{struct_serial_u_a_r_t_1_1_status}{Status}}. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_acbb058f8002a9bd9e3fdbcbd8ecdf88f}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_acbb058f8002a9bd9e3fdbcbd8ecdf88f}} 
void {\bfseries Enable\+Error\+IRQ} (bool enable=true)
\begin{DoxyCompactList}\small\item\em Enabler for Error interrupt. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
UART serial communication controller object 

This is a UART serial communication controller which manages a single peripheral. It creates two FIFO queues for transmission and reception of data over UART and some simple parsing capabilities. This controller is interrupt driven, so \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a92e007bfb65edacf4a77e38c0d90c00a}{ISR()}} must be implemented in the UART interrupt handler (pay attention to which SERCOM\# you are using). The ISR provides interrupt and error flags and can be read using \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a0981486823056dda314018359b9159af}{Get\+Status()}} to implement your own error and interrupt handling outside of basic data transmission/reception. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af85abfd70eb695772bb00fbf3e794b70}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af85abfd70eb695772bb00fbf3e794b70}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!UARTController@{UARTController}}
\index{UARTController@{UARTController}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{UARTController()}{UARTController()}}
{\footnotesize\ttfamily Serial\+UART\+::\+UARTController\+::\+UARTController (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Constructor. 

Instantiates controller object for UART serial communication.~\newline
 This will not initialize the hardware, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init()}} must be called before transmission and reception will do anything.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6af0ef220033acccc163141be0223200}{$\sim$\+UARTController()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}{Deinit()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6af0ef220033acccc163141be0223200}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6af0ef220033acccc163141be0223200}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!````~UARTController@{$\sim$UARTController}}
\index{````~UARTController@{$\sim$UARTController}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{$\sim$UARTController()}{~UARTController()}}
{\footnotesize\ttfamily Serial\+UART\+::\+UARTController\+::$\sim$\+UARTController (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Destructor. 

Called when \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller}{UARTController}} object is destroyed. Immediately halts data transmission and resets peripheral hardware.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af85abfd70eb695772bb00fbf3e794b70}{UARTController()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}{Deinit()}} 
\end{DoxySeeAlso}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6e154b891bf847e222fd3509910a1acb}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6e154b891bf847e222fd3509910a1acb}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ClearBuffers@{ClearBuffers}}
\index{ClearBuffers@{ClearBuffers}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ClearBuffers()}{ClearBuffers()}}
{\footnotesize\ttfamily void Serial\+UART\+::\+UARTController\+::\+Clear\+Buffers (\begin{DoxyParamCaption}\item[{bool}]{clear\+\_\+tx = {\ttfamily true},  }\item[{bool}]{clear\+\_\+rx = {\ttfamily true} }\end{DoxyParamCaption})}



Clears Rx and/or Tx buffers. 

Clears out the receive and/or transmit buffers and resets status data and indices.~\newline
 Useful for quick handling of full buffers and errors.


\begin{DoxyParams}{Parameters}
{\em clear\+\_\+tx} & clear transmit buffer (default = true) \\
\hline
{\em clear\+\_\+rx} & clear receive buffer (default = true) \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}{Deinit()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6e154b891bf847e222fd3509910a1acb_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!Deinit@{Deinit}}
\index{Deinit@{Deinit}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{Deinit()}{Deinit()}}
{\footnotesize\ttfamily void Serial\+UART\+::\+UARTController\+::\+Deinit (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Disables and resets UART serial communication. 

Disables UART serial controller if active and resets peripheral hardware. UART controller can be initialized again after calling this function without destroying entire object.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6e154b891bf847e222fd3509910a1acb}{Clear\+Buffers()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6af0ef220033acccc163141be0223200}{$\sim$\+UARTController()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_aa6127de65b6715caf5171630fc7c0b09}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_aa6127de65b6715caf5171630fc7c0b09}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!EchoRx@{EchoRx}}
\index{EchoRx@{EchoRx}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{EchoRx()}{EchoRx()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Echo\+Rx (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Transmits char from the receive buffer. 

Reads from logic layer receive buffer and adds read char into logic layer transmit buffer. Ideally used to echo received data onto serial terminal.~\newline
 Returns true/false based on success of transmission. Transmission will fail if instance is disabled, TX buffer is full, or RX buffer is empty.

\begin{DoxyReturn}{Returns}
success of transmission 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function is ISR friendly. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}{Transmit()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}{Receive()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a0981486823056dda314018359b9159af}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a0981486823056dda314018359b9159af}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!GetStatus@{GetStatus}}
\index{GetStatus@{GetStatus}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{GetStatus()}{GetStatus()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_serial_u_a_r_t_1_1_status}{Serial\+UART\+::\+Status}} Serial\+UART\+::\+UARTController\+::\+Get\+Status (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption}) const}



Getter for errors, interrupts, and power state. 

Useful for adding additional ISR responses in SERCOM handler.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a92e007bfb65edacf4a77e38c0d90c00a}{ISR()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a64dcc4207f50cbe72a0faf5085223a42}{Clear\+TXInterrupt()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ac3399e6c6eaed563b8c474533e49f205}{Clear\+RXInterrupt()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a84312b3ecd69219152e3fdc239b1cfba}{Clear\+Errors()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!Init@{Init}}
\index{Init@{Init}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{Init()}{Init()}}
{\footnotesize\ttfamily void Serial\+UART\+::\+UARTController\+::\+Init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t_h_a_l_1_1_peripheral}{UARTHAL\+::\+Peripheral}} $\ast$}]{p\+\_\+config,  }\item[{char $\ast$}]{tx\+\_\+buf,  }\item[{uint32\+\_\+t}]{tx\+\_\+size,  }\item[{char $\ast$}]{rx\+\_\+buf,  }\item[{uint32\+\_\+t}]{rx\+\_\+size }\end{DoxyParamCaption})}



Initializes UART serial communication. 

Uses five parameters for peripheral config and buffer sizes to initialize peripheral hardware, buffers, and statuses if UART hasn\textquotesingle{}t been initialized.~\newline
 This function will not do anything if UART is currently enabled.


\begin{DoxyParams}{Parameters}
{\em p\+\_\+config} & pointer to peripheral config information \\
\hline
{\em rx\+\_\+buf} & initialized character array used for receive buffer \\
\hline
{\em rx\+\_\+size} & receive buffer size \\
\hline
{\em rx\+\_\+buf} & initialized character array used for transmit buffer \\
\hline
{\em tx\+\_\+size} & transmit buffer size \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab90c37bccfd58212dc13c32338859007}{Deinit()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab23205f9716835204b376bd6326a0aae}{Reset\+TXBuffer()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a7fc563163f811d74b8f901a1d0c3d302}{Reset\+RXBuffer()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_acbb058f8002a9bd9e3fdbcbd8ecdf88f}{Enable\+Error\+IRQ()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a92e007bfb65edacf4a77e38c0d90c00a}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a92e007bfb65edacf4a77e38c0d90c00a}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ISR@{ISR}}
\index{ISR@{ISR}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ISR()}{ISR()}}
{\footnotesize\ttfamily void Serial\+UART\+::\+UARTController\+::\+ISR (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Interrupt Service Routine. 

Function to be called in corresponding SERCOM\# interrupt handler. Sets IRQ and error statuses, populates receive buffer, and transmits data from the transmit buffer.~\newline
 Interrupts can be read with \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a0981486823056dda314018359b9159af}{Get\+Status()}} to handle synchronization of events, check and handle errors, and generally assist with debugging.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a0981486823056dda314018359b9159af}{Get\+Status()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a64dcc4207f50cbe72a0faf5085223a42}{Clear\+TXInterrupt()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ac3399e6c6eaed563b8c474533e49f205}{Clear\+RXInterrupt()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a84312b3ecd69219152e3fdc239b1cfba}{Clear\+Errors()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a92e007bfb65edacf4a77e38c0d90c00a_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!Receive@{Receive}}
\index{Receive@{Receive}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{Receive()}{Receive()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Receive (\begin{DoxyParamCaption}\item[{char $\ast$}]{output = {\ttfamily nullptr} }\end{DoxyParamCaption})}



Receive character from logic layer receive buffer and free buffer space. 

Receives character from logic layer receive buffer, updates rx reader pointer, status, number of available rx buffer slots.


\begin{DoxyParams}{Parameters}
{\em output} & pointer to received char (default = nullptr) ~\newline
 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success of reception 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}{Receive\+String()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be}{Receive\+Int()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14}{Receive\+Param()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_aa6127de65b6715caf5171630fc7c0b09}{Echo\+Rx()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ReceiveInt@{ReceiveInt}}
\index{ReceiveInt@{ReceiveInt}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ReceiveInt()}{ReceiveInt()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Receive\+Int (\begin{DoxyParamCaption}\item[{uint32\+\_\+t $\ast$}]{output }\end{DoxyParamCaption})}



Receives ASCII number and outputs unsigned int. 

Reads receive buffer until empty or non-\/numeric ASCII character received, and converts to unsigned int.


\begin{DoxyParams}{Parameters}
{\em output} & pointer to received int value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success of reception (returns false if no integer was detected) 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}{Receive()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14}{Receive\+Param()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}{Receive\+String()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ReceiveParam@{ReceiveParam}}
\index{ReceiveParam@{ReceiveParam}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ReceiveParam()}{ReceiveParam()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Receive\+Param (\begin{DoxyParamCaption}\item[{uint32\+\_\+t $\ast$}]{output,  }\item[{const char $\ast$}]{input,  }\item[{char}]{delimiter = {\ttfamily \textquotesingle{}\textbackslash{}0\textquotesingle{}},  }\item[{uint8\+\_\+t}]{max\+\_\+digits = {\ttfamily 8u} }\end{DoxyParamCaption})}



Checks if input string followed by an ASCII parameter has been received from USART and returns the ASCII parameter as unsigned int. 

Checks input string with front of receive buffer with offset \mbox{[}1, max\+\_\+digits\mbox{]}, and then returns the following ASCII number characters as unsigned int.~\newline
 Call Has\+Received\+Param() immediately after call to ensure string has been received.~\newline
 Example\+: Receive\+Param(\char`\"{}c\+\_\+\char`\"{}) will output unsigned int 12u if \char`\"{}c\+\_\+12\char`\"{} is sent via USART.~\newline
 Can also be used multiple times for different strings with parameters and in conjunction with \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}{Receive\+String()}} calls.~\newline
 Iterates rx read index.~\newline
 If a string is detected, all calls will be disabled until a new character is received.~\newline
 delimiter parameter will detect an end-\/character if set to nonzero to allow for more secure message reading.~\newline
 max\+\_\+digits parameter will set a bound for the max amount of digits in the parameter. If max\+\_\+digits \texorpdfstring{$>$}{>} 9, the return value may not be what is expected.


\begin{DoxyParams}{Parameters}
{\em output} & pointer to received int value \\
\hline
{\em input} & input character array to be detected \\
\hline
{\em delimiter} & optional delimiting character after int parameter (default = \textquotesingle{}\textbackslash{}0\textquotesingle{}) \\
\hline
{\em max\+\_\+digits} & maximum number of digits in parameter, must not exceed 9 (default = 8) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success of reception (will return false if string value not detected, no integer detected, or no delimiter detected if set) 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Input array must be null-\/character terminated. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}{Receive()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}{Receive\+String()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be}{Receive\+Int()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ReceiveString@{ReceiveString}}
\index{ReceiveString@{ReceiveString}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ReceiveString()}{ReceiveString()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Receive\+String (\begin{DoxyParamCaption}\item[{const char $\ast$}]{input,  }\item[{uint32\+\_\+t}]{shift = {\ttfamily 0u},  }\item[{bool}]{move\+\_\+pointer = {\ttfamily true} }\end{DoxyParamCaption})}



Checks if input string has been received from USART. 

Checks input string with front of receive buffer, returning true if the input string has been detected.~\newline
 Can be used multiple times for different strings.~\newline
 Iterates rx read index.~\newline
 If a string is detected, all calls will be disabled until a new character is received.~\newline
 Shift parameter detects substring offset by shift places. Useful for detecting a command with parameter (i.\+e. \char`\"{}c\+\_\+25\char`\"{}).~\newline
 Moves the receive buffer pointer back to the end of the substring if move\+\_\+pointer is set to true.


\begin{DoxyParams}{Parameters}
{\em input} & char array to be detected \\
\hline
{\em shift} & offset of string from end of receive buffer (default = 0) \\
\hline
{\em move\+\_\+pointer} & moves rx\+\_\+rd\+\_\+index to end of detected string if shift is on (default = true) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
if string has been received 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Input array must be null-\/character terminated. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af7f47359ebd93eb963a25ddcf2f82e95}{Receive()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_af32a208d38efa9b6f59abe90007f8f14}{Receive\+Param()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ad7faff77724cdef304aba335cb8cf6be}{Receive\+Int()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a61f2d80e5a462f4312bec7be7fa70c89_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a7fc563163f811d74b8f901a1d0c3d302}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a7fc563163f811d74b8f901a1d0c3d302}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ResetRXBuffer@{ResetRXBuffer}}
\index{ResetRXBuffer@{ResetRXBuffer}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ResetRXBuffer()}{ResetRXBuffer()}}
{\footnotesize\ttfamily void Serial\+UART\+::\+UARTController\+::\+Reset\+RXBuffer (\begin{DoxyParamCaption}\item[{char $\ast$}]{rx\+\_\+buf,  }\item[{uint32\+\_\+t}]{rx\+\_\+size }\end{DoxyParamCaption})}



Resets receive buffer. 

Resets UART controller receive buffer to use a new input array and buffer size. Resets RXIRQ status and error status.


\begin{DoxyParams}{Parameters}
{\em rx\+\_\+buf} & initialized character array used for receive buffer \\
\hline
{\em rx\+\_\+size} & receive buffer size \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab23205f9716835204b376bd6326a0aae}{Reset\+TXBuffer}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a7fc563163f811d74b8f901a1d0c3d302_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab23205f9716835204b376bd6326a0aae}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab23205f9716835204b376bd6326a0aae}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!ResetTXBuffer@{ResetTXBuffer}}
\index{ResetTXBuffer@{ResetTXBuffer}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{ResetTXBuffer()}{ResetTXBuffer()}}
{\footnotesize\ttfamily void Serial\+UART\+::\+UARTController\+::\+Reset\+TXBuffer (\begin{DoxyParamCaption}\item[{char $\ast$}]{tx\+\_\+buf,  }\item[{uint32\+\_\+t}]{tx\+\_\+size }\end{DoxyParamCaption})}



Resets transmit buffer. 

Resets UART controller transmit buffer to use a new input array and buffer size. Resets TXIRQ status.


\begin{DoxyParams}{Parameters}
{\em tx\+\_\+buf} & initialized character array used for transmit buffer \\
\hline
{\em tx\+\_\+size} & transmit buffer size \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a7fc563163f811d74b8f901a1d0c3d302}{Reset\+RXBuffer()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a70cc27f9c5e3920954e4b2dea8e5d7b8}{Init()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_ab23205f9716835204b376bd6326a0aae_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!Transmit@{Transmit}}
\index{Transmit@{Transmit}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{Transmit()}{Transmit()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Transmit (\begin{DoxyParamCaption}\item[{char}]{input }\end{DoxyParamCaption})}



Transmit character into logic layer transmit buffer to be sent to USART data buffer. 

Transmits character into logic layer transmit buffer, updates tx writer pointer, status, number of available tx buffer slots.~\newline
 Returns a true/false based on success of transmission. Transmission will fail if logic layer transmit buffer is full.


\begin{DoxyParams}{Parameters}
{\em input} & character to be transmitted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success of transmission 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a63d71a7be771a2c8d435af6853df1e84}{Transmit\+String()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923}{Transmit\+Int()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_aa6127de65b6715caf5171630fc7c0b09}{Echo\+Rx()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!TransmitInt@{TransmitInt}}
\index{TransmitInt@{TransmitInt}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{TransmitInt()}{TransmitInt()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Transmit\+Int (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{input }\end{DoxyParamCaption})}



Transmits unsigned int as ASCII string. 

Transmits each digit as an ASCII string.~\newline
 Returns false is UART is off.


\begin{DoxyParams}{Parameters}
{\em input} & raw value of integer to be transmitted as ASCII characters \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success of transmission 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}{Transmit()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a63d71a7be771a2c8d435af6853df1e84}{Transmit\+String()}} 
\end{DoxySeeAlso}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_acc003e020b56fc1c8a6c4a9433ebe2d9}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_acc003e020b56fc1c8a6c4a9433ebe2d9}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!TransmitPacket@{TransmitPacket}}
\index{TransmitPacket@{TransmitPacket}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{TransmitPacket()}{TransmitPacket()}}
{\footnotesize\ttfamily bool Serial\+UART\+::\+UARTController\+::\+Transmit\+Packet (\begin{DoxyParamCaption}\item[{const char $\ast$}]{input,  }\item[{uint32\+\_\+t}]{num\+\_\+bytes }\end{DoxyParamCaption})}



Transmits a packet of bytes, which do not need to be null-\/terminated. 

Transmits an array of characters given the number of characters to transmit. Good for sending raw bytes rather than ASCII characters.


\begin{DoxyParams}{Parameters}
{\em input} & char array to be sent to host \\
\hline
{\em num\+\_\+bytes} & number of bytes to be sent to host \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
success of transmission 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}{Transmit()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a63d71a7be771a2c8d435af6853df1e84}{Transmit\+String()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923}{Transmit\+Int()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a63d71a7be771a2c8d435af6853df1e84}\label{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a63d71a7be771a2c8d435af6853df1e84}} 
\index{SerialUART::UARTController@{SerialUART::UARTController}!TransmitString@{TransmitString}}
\index{TransmitString@{TransmitString}!SerialUART::UARTController@{SerialUART::UARTController}}
\doxysubsubsection{\texorpdfstring{TransmitString()}{TransmitString()}}
{\footnotesize\ttfamily uint32\+\_\+t Serial\+UART\+::\+UARTController\+::\+Transmit\+String (\begin{DoxyParamCaption}\item[{const char $\ast$}]{input }\end{DoxyParamCaption})}



Transmit an entire char array at once. 

Adds an entire char array to the logic layer transmit buffer at once.~\newline
 Returns true/false based on success of transmission.


\begin{DoxyParams}{Parameters}
{\em input} & char array to be transmitted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes sent 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Input array must be null-\/character terminated. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a6115ee08a68979d93ee22489937fa262}{Transmit()}}, \mbox{\hyperlink{class_serial_u_a_r_t_1_1_u_a_r_t_controller_a97e30c5cec5953dad0167ba0e96c8923}{Transmit\+Int()}} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Serial\+Library\+Example/serial\+\_\+controllers/serial\+\_\+uart/serial\+\_\+uart.\+h\item 
Serial\+Library\+Example/serial\+\_\+controllers/serial\+\_\+uart/serial\+\_\+uart.\+cpp\end{DoxyCompactItemize}
