<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded C++ Serial Communication Library: SerialUSB::USBController Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded C++ Serial Communication Library
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">A custom C++ serial communication library for easy configuration and implementation of serial communication protocols.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_serial_u_s_b.html">SerialUSB</a></li><li class="navelem"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html">USBController</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_serial_u_s_b_1_1_u_s_b_controller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SerialUSB::USBController Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>USB serial communication controller object  
 <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="serial__usb_8h_source.html">serial_usb.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afe81951c2ec599df97a3e02a077c8b7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afe81951c2ec599df97a3e02a077c8b7d">USBController</a> (void)</td></tr>
<tr class="memdesc:afe81951c2ec599df97a3e02a077c8b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#afe81951c2ec599df97a3e02a077c8b7d">More...</a><br /></td></tr>
<tr class="separator:afe81951c2ec599df97a3e02a077c8b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818f91a71f7cac12cee2a8e9cb69634c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a818f91a71f7cac12cee2a8e9cb69634c">~USBController</a> (void)</td></tr>
<tr class="memdesc:a818f91a71f7cac12cee2a8e9cb69634c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a818f91a71f7cac12cee2a8e9cb69634c">More...</a><br /></td></tr>
<tr class="separator:a818f91a71f7cac12cee2a8e9cb69634c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b3b3f5b75c8409ac7c31ae99a9c86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b">Init</a> (char *buf, uint32_t buf_size)</td></tr>
<tr class="memdesc:a14b3b3f5b75c8409ac7c31ae99a9c86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes USB serial communication.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b">More...</a><br /></td></tr>
<tr class="separator:a14b3b3f5b75c8409ac7c31ae99a9c86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4b8c8717abfbd6d92fcb72e11b093a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa4b8c8717abfbd6d92fcb72e11b093a">Deinit</a> (void)</td></tr>
<tr class="memdesc:afa4b8c8717abfbd6d92fcb72e11b093a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables and resets USB serial communication.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa4b8c8717abfbd6d92fcb72e11b093a">More...</a><br /></td></tr>
<tr class="separator:afa4b8c8717abfbd6d92fcb72e11b093a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7e36dd99bc47027609623f39ec467a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#aae7e36dd99bc47027609623f39ec467a">ResetBuffer</a> (char *buf, uint32_t buf_size)</td></tr>
<tr class="memdesc:aae7e36dd99bc47027609623f39ec467a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets FIFO receive buffer.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#aae7e36dd99bc47027609623f39ec467a">More...</a><br /></td></tr>
<tr class="separator:aae7e36dd99bc47027609623f39ec467a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1cf32ce7de220c579415e496370bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a4c1cf32ce7de220c579415e496370bb9">ClearBuffers</a> (bool clear_tx=true, bool clear_rx=true)</td></tr>
<tr class="memdesc:a4c1cf32ce7de220c579415e496370bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears Rx and/or Tx buffers.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a4c1cf32ce7de220c579415e496370bb9">More...</a><br /></td></tr>
<tr class="separator:a4c1cf32ce7de220c579415e496370bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3721932b0112fe15c43a969a06d1144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#af3721932b0112fe15c43a969a06d1144">ISR</a> (void)</td></tr>
<tr class="memdesc:af3721932b0112fe15c43a969a06d1144"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Interrupt Service Routine.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#af3721932b0112fe15c43a969a06d1144">More...</a><br /></td></tr>
<tr class="separator:af3721932b0112fe15c43a969a06d1144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5802a3f2aebbf57800b613339a66f84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b">Task</a> (bool echo=false)</td></tr>
<tr class="memdesc:a5802a3f2aebbf57800b613339a66f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Task Routine.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b">More...</a><br /></td></tr>
<tr class="separator:a5802a3f2aebbf57800b613339a66f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016f4dfe9a3fd5185d1eb38330a3d950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a016f4dfe9a3fd5185d1eb38330a3d950">Transmit</a> (char input)</td></tr>
<tr class="memdesc:a016f4dfe9a3fd5185d1eb38330a3d950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit character across USB.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a016f4dfe9a3fd5185d1eb38330a3d950">More...</a><br /></td></tr>
<tr class="separator:a016f4dfe9a3fd5185d1eb38330a3d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7345066fbeeecdfc6320af05c95838"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa7345066fbeeecdfc6320af05c95838">Receive</a> (char *output=nullptr)</td></tr>
<tr class="memdesc:afa7345066fbeeecdfc6320af05c95838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive character across USB from host.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa7345066fbeeecdfc6320af05c95838">More...</a><br /></td></tr>
<tr class="separator:afa7345066fbeeecdfc6320af05c95838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808ce3f51a820009b04e46cba483de4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a808ce3f51a820009b04e46cba483de4e">TransmitPacket</a> (const char *input, uint32_t num_bytes)</td></tr>
<tr class="memdesc:a808ce3f51a820009b04e46cba483de4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a packet of bytes, which do not need to be null-terminated.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a808ce3f51a820009b04e46cba483de4e">More...</a><br /></td></tr>
<tr class="separator:a808ce3f51a820009b04e46cba483de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4ae218bf10826e4943b542d782695c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#aea4ae218bf10826e4943b542d782695c">TransmitString</a> (const char *input)</td></tr>
<tr class="memdesc:aea4ae218bf10826e4943b542d782695c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit string across USB.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#aea4ae218bf10826e4943b542d782695c">More...</a><br /></td></tr>
<tr class="separator:aea4ae218bf10826e4943b542d782695c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3331f2f23514b6980ef07623f3674b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a8e3331f2f23514b6980ef07623f3674b">ReceiveString</a> (const char *input, uint32_t shift=0u, bool move_pointer=true)</td></tr>
<tr class="memdesc:a8e3331f2f23514b6980ef07623f3674b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if input string has been received over USB from host.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a8e3331f2f23514b6980ef07623f3674b">More...</a><br /></td></tr>
<tr class="separator:a8e3331f2f23514b6980ef07623f3674b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41534109837d3f7557049e6d67fdfac0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a41534109837d3f7557049e6d67fdfac0">TransmitInt</a> (uint32_t input)</td></tr>
<tr class="memdesc:a41534109837d3f7557049e6d67fdfac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits unsigned int as ASCII string over USB.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a41534109837d3f7557049e6d67fdfac0">More...</a><br /></td></tr>
<tr class="separator:a41534109837d3f7557049e6d67fdfac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e39a9bf73b5134ff0eb72b36b218f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#ab3e39a9bf73b5134ff0eb72b36b218f8">ReceiveInt</a> (uint32_t *output)</td></tr>
<tr class="memdesc:ab3e39a9bf73b5134ff0eb72b36b218f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives ASCII number across USB from host and returns unsigned int.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#ab3e39a9bf73b5134ff0eb72b36b218f8">More...</a><br /></td></tr>
<tr class="separator:ab3e39a9bf73b5134ff0eb72b36b218f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f742c399f9ad7bcc5719b9aa8a24ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a1f742c399f9ad7bcc5719b9aa8a24ff0">ReceiveParam</a> (uint32_t *output, const char *input, char delimiter='\0', uint8_t max_digits=8u)</td></tr>
<tr class="memdesc:a1f742c399f9ad7bcc5719b9aa8a24ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if input string followed by an ASCII parameter has been received across USB from host and returns the ASCII parameter as unsigned int.  <a href="class_serial_u_s_b_1_1_u_s_b_controller.html#a1f742c399f9ad7bcc5719b9aa8a24ff0">More...</a><br /></td></tr>
<tr class="separator:a1f742c399f9ad7bcc5719b9aa8a24ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58aebc93cd2f34a581b2b9aaa34caf"><td class="memItemLeft" align="right" valign="top"><a id="a9f58aebc93cd2f34a581b2b9aaa34caf"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a9f58aebc93cd2f34a581b2b9aaa34caf">GetBufferAvailable</a> (void) const</td></tr>
<tr class="memdesc:a9f58aebc93cd2f34a581b2b9aaa34caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for number of unread characters available in FIFO receive buffer. <br /></td></tr>
<tr class="separator:a9f58aebc93cd2f34a581b2b9aaa34caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af52968c68586221f74d293b2cf5669"><td class="memItemLeft" align="right" valign="top"><a id="a7af52968c68586221f74d293b2cf5669"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a7af52968c68586221f74d293b2cf5669">IsConnected</a> (void) const</td></tr>
<tr class="memdesc:a7af52968c68586221f74d293b2cf5669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves state of connection (true = connected) <br  />
 <br /></td></tr>
<tr class="separator:a7af52968c68586221f74d293b2cf5669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace06a48c2154c6692f42630d2b35df4a"><td class="memItemLeft" align="right" valign="top"><a id="ace06a48c2154c6692f42630d2b35df4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#ace06a48c2154c6692f42630d2b35df4a">Detach</a> (void)</td></tr>
<tr class="memdesc:ace06a48c2154c6692f42630d2b35df4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspends USB device to go into low power mode <br  />
 <br /></td></tr>
<tr class="separator:ace06a48c2154c6692f42630d2b35df4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2bad9d6fe85f10aa9288c9735ee68b"><td class="memItemLeft" align="right" valign="top"><a id="a4c2bad9d6fe85f10aa9288c9735ee68b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a4c2bad9d6fe85f10aa9288c9735ee68b">Reattach</a> (void)</td></tr>
<tr class="memdesc:a4c2bad9d6fe85f10aa9288c9735ee68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reattaches suspended USB device. <br /></td></tr>
<tr class="separator:a4c2bad9d6fe85f10aa9288c9735ee68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>USB serial communication controller object </p>
<p>This is a USB serial communication controller which manages a single peripheral. It creates a SerialBuffer for reception of data over USB and some simple parsing capabilities. This controller is interrupt and task driven, so <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> must be implemented before or after all application code in the main while loop, and <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#af3721932b0112fe15c43a969a06d1144" title="USB Interrupt Service Routine.">ISR()</a> must be implemented in the USB interrupt Handler. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe81951c2ec599df97a3e02a077c8b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe81951c2ec599df97a3e02a077c8b7d">&#9670;&nbsp;</a></span>USBController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SerialUSB::USBController::USBController </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Instantiates controller object for USB serial communication. This will use the TinyUSB stack to perform the necessary tasks. The object instance must be initialized using <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b" title="Initializes USB serial communication.">Init()</a> to begin using it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a818f91a71f7cac12cee2a8e9cb69634c" title="Destructor.">~USBController()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b" title="Initializes USB serial communication.">Init()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa4b8c8717abfbd6d92fcb72e11b093a" title="Disables and resets USB serial communication.">Deinit()</a> </dd></dl>

</div>
</div>
<a id="a818f91a71f7cac12cee2a8e9cb69634c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f91a71f7cac12cee2a8e9cb69634c">&#9670;&nbsp;</a></span>~USBController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SerialUSB::USBController::~USBController </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Called when UARTController object is destroyed. Immediately halts data transmission.</p>
<dl class="section note"><dt>Note</dt><dd>The hardware teardown for TinyUSB is currently unimplemented. It is not recommended to call the destructor manually. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afe81951c2ec599df97a3e02a077c8b7d" title="Constructor.">USBController()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b" title="Initializes USB serial communication.">Init()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa4b8c8717abfbd6d92fcb72e11b093a" title="Disables and resets USB serial communication.">Deinit()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4c1cf32ce7de220c579415e496370bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1cf32ce7de220c579415e496370bb9">&#9670;&nbsp;</a></span>ClearBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialUSB::USBController::ClearBuffers </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_tx</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_rx</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears Rx and/or Tx buffers. </p>
<p>Clears out the receive and/or transmit buffers and resets status data and indices.<br  />
 Useful for quick handling of full buffers and errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_tx</td><td>clear transmit buffer (default = true) </td></tr>
    <tr><td class="paramname">clear_rx</td><td>clear receive buffer (default = true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa4b8c8717abfbd6d92fcb72e11b093a" title="Disables and resets USB serial communication.">Deinit()</a> </dd></dl>

</div>
</div>
<a id="afa4b8c8717abfbd6d92fcb72e11b093a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4b8c8717abfbd6d92fcb72e11b093a">&#9670;&nbsp;</a></span>Deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialUSB::USBController::Deinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables and resets USB serial communication. </p>
<p>Disables USB serial controller if active.</p>
<dl class="section note"><dt>Note</dt><dd>The hardware teardown for TinyUSB is currently unimplemented. It is not recommended to call this. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b" title="Initializes USB serial communication.">Init()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a4c1cf32ce7de220c579415e496370bb9" title="Clears Rx and/or Tx buffers.">ClearBuffers()</a>, ~UARTController() </dd></dl>

</div>
</div>
<a id="a14b3b3f5b75c8409ac7c31ae99a9c86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b3b3f5b75c8409ac7c31ae99a9c86b">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialUSB::USBController::Init </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes USB serial communication. </p>
<p>Initializes peripheral hardware and uses optional parameter for FIFO buffer size if USB hasn't been initialized.<br  />
 This function will not do anything if USB is currently enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>initialized character array used for FIFO receive buffer </td></tr>
    <tr><td class="paramname">buf_size</td><td>buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa4b8c8717abfbd6d92fcb72e11b093a" title="Disables and resets USB serial communication.">Deinit()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#aae7e36dd99bc47027609623f39ec467a" title="Resets FIFO receive buffer.">ResetBuffer()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_serial_u_s_b_1_1_u_s_b_controller_a14b3b3f5b75c8409ac7c31ae99a9c86b_cgraph.png" border="0" usemap="#aclass_serial_u_s_b_1_1_u_s_b_controller_a14b3b3f5b75c8409ac7c31ae99a9c86b_cgraph" alt=""/></div>
<map name="aclass_serial_u_s_b_1_1_u_s_b_controller_a14b3b3f5b75c8409ac7c31ae99a9c86b_cgraph" id="aclass_serial_u_s_b_1_1_u_s_b_controller_a14b3b3f5b75c8409ac7c31ae99a9c86b_cgraph">
<area shape="rect" title="Initializes USB serial communication." alt="" coords="5,5,191,47"/>
<area shape="rect" href="namespace_serial_u_s_b.html#ae740bbae65f8f49b75efde592bb3a049" title="A helper function for initializing clocks and I/O pins on specific chip." alt="" coords="239,13,448,39"/>
</map>
</div>

</div>
</div>
<a id="af3721932b0112fe15c43a969a06d1144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3721932b0112fe15c43a969a06d1144">&#9670;&nbsp;</a></span>ISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialUSB::USBController::ISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Interrupt Service Routine. </p>
<p>Function to be called in USB interrupt handler. This calls the tusb ISR function and lets the USB stack handle interrupts.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>

</div>
</div>
<a id="afa7345066fbeeecdfc6320af05c95838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7345066fbeeecdfc6320af05c95838">&#9670;&nbsp;</a></span>Receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::Receive </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>output</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive character across USB from host. </p>
<p>Uses controller FIFO receive buffer to get the next unread character from the received data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>pointer to received char (default = nullptr) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of reception </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a8e3331f2f23514b6980ef07623f3674b" title="Checks if input string has been received over USB from host.">ReceiveString()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#ab3e39a9bf73b5134ff0eb72b36b218f8" title="Receives ASCII number across USB from host and returns unsigned int.">ReceiveInt()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a1f742c399f9ad7bcc5719b9aa8a24ff0" title="Checks if input string followed by an ASCII parameter has been received across USB from host and retu...">ReceiveParam()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_serial_u_s_b_1_1_u_s_b_controller_afa7345066fbeeecdfc6320af05c95838_cgraph.png" border="0" usemap="#aclass_serial_u_s_b_1_1_u_s_b_controller_afa7345066fbeeecdfc6320af05c95838_cgraph" alt=""/></div>
<map name="aclass_serial_u_s_b_1_1_u_s_b_controller_afa7345066fbeeecdfc6320af05c95838_cgraph" id="aclass_serial_u_s_b_1_1_u_s_b_controller_afa7345066fbeeecdfc6320af05c95838_cgraph">
<area shape="rect" title="Receive character across USB from host." alt="" coords="5,5,191,47"/>
<area shape="rect" href="namespace_serial.html#a765e3d30c8e412dd3eb1627312b3d4de" title="Blank Interrupt Enable function to be used as blank parameter for implementing serial buffer." alt="" coords="239,13,385,39"/>
</map>
</div>

</div>
</div>
<a id="ab3e39a9bf73b5134ff0eb72b36b218f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e39a9bf73b5134ff0eb72b36b218f8">&#9670;&nbsp;</a></span>ReceiveInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::ReceiveInt </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives ASCII number across USB from host and returns unsigned int. </p>
<p>Reads FIFO receive buffer until empty or non-numeric ASCII character received, and converts to unsigned int.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>pointer to received int value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of reception (returns false if no integer was detected) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa7345066fbeeecdfc6320af05c95838" title="Receive character across USB from host.">Receive()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a1f742c399f9ad7bcc5719b9aa8a24ff0" title="Checks if input string followed by an ASCII parameter has been received across USB from host and retu...">ReceiveParam()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a8e3331f2f23514b6980ef07623f3674b" title="Checks if input string has been received over USB from host.">ReceiveString()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_serial_u_s_b_1_1_u_s_b_controller_ab3e39a9bf73b5134ff0eb72b36b218f8_cgraph.png" border="0" usemap="#aclass_serial_u_s_b_1_1_u_s_b_controller_ab3e39a9bf73b5134ff0eb72b36b218f8_cgraph" alt=""/></div>
<map name="aclass_serial_u_s_b_1_1_u_s_b_controller_ab3e39a9bf73b5134ff0eb72b36b218f8_cgraph" id="aclass_serial_u_s_b_1_1_u_s_b_controller_ab3e39a9bf73b5134ff0eb72b36b218f8_cgraph">
<area shape="rect" title="Receives ASCII number across USB from host and returns unsigned int." alt="" coords="5,5,191,47"/>
<area shape="rect" href="namespace_serial.html#a765e3d30c8e412dd3eb1627312b3d4de" title="Blank Interrupt Enable function to be used as blank parameter for implementing serial buffer." alt="" coords="239,13,385,39"/>
</map>
</div>

</div>
</div>
<a id="a1f742c399f9ad7bcc5719b9aa8a24ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f742c399f9ad7bcc5719b9aa8a24ff0">&#9670;&nbsp;</a></span>ReceiveParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::ReceiveParam </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delimiter</em> = <code>'\0'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_digits</em> = <code>8u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if input string followed by an ASCII parameter has been received across USB from host and returns the ASCII parameter as unsigned int. </p>
<p>Checks input string with front of receive buffer with offset [1, max_digits], and then returns the following ASCII number characters as unsigned int.<br  />
 Call HasReceivedParam() immediately after call to ensure string has been received.<br  />
 Example: ReceiveParam("c_") will output unsigned int 12u if "c_12" is sent via USB.<br  />
 Can also be used multiple times for different strings with parameters and in conjunction with <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a8e3331f2f23514b6980ef07623f3674b" title="Checks if input string has been received over USB from host.">ReceiveString()</a> calls.<br  />
 Iterates rx read index.<br  />
If a string is detected, all calls will be disabled until a new character is received.<br  />
 delimiter parameter will detect an end-character if set to nonzero to allow for more secure message reading.<br  />
 max_digits parameter will set a bound for the max amount of digits in the parameter. If max_digits &gt; 9, the return value may not be what is expected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>pointer to received int value </td></tr>
    <tr><td class="paramname">input</td><td>input character array to be detected </td></tr>
    <tr><td class="paramname">delimiter</td><td>optional delimiting character after int parameter (default = '\0') </td></tr>
    <tr><td class="paramname">max_digits</td><td>maximum number of digits in parameter, must not exceed 9 (default = 8) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of reception (will return false if string value not detected, no integer detected, or no delimiter detected if set) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Input array must be null-character terminated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa7345066fbeeecdfc6320af05c95838" title="Receive character across USB from host.">Receive()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a8e3331f2f23514b6980ef07623f3674b" title="Checks if input string has been received over USB from host.">ReceiveString()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#ab3e39a9bf73b5134ff0eb72b36b218f8" title="Receives ASCII number across USB from host and returns unsigned int.">ReceiveInt()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_serial_u_s_b_1_1_u_s_b_controller_a1f742c399f9ad7bcc5719b9aa8a24ff0_cgraph.png" border="0" usemap="#aclass_serial_u_s_b_1_1_u_s_b_controller_a1f742c399f9ad7bcc5719b9aa8a24ff0_cgraph" alt=""/></div>
<map name="aclass_serial_u_s_b_1_1_u_s_b_controller_a1f742c399f9ad7bcc5719b9aa8a24ff0_cgraph" id="aclass_serial_u_s_b_1_1_u_s_b_controller_a1f742c399f9ad7bcc5719b9aa8a24ff0_cgraph">
<area shape="rect" title="Checks if input string followed by an ASCII parameter has been received across USB from host and retu..." alt="" coords="5,5,191,47"/>
<area shape="rect" href="namespace_serial.html#a765e3d30c8e412dd3eb1627312b3d4de" title="Blank Interrupt Enable function to be used as blank parameter for implementing serial buffer." alt="" coords="239,13,385,39"/>
</map>
</div>

</div>
</div>
<a id="a8e3331f2f23514b6980ef07623f3674b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3331f2f23514b6980ef07623f3674b">&#9670;&nbsp;</a></span>ReceiveString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::ReceiveString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_pointer</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if input string has been received over USB from host. </p>
<p>Checks input string with front of FIFO receive buffer, returning true if the input string has been detected.<br  />
 Can be used multiple times for different strings.<br  />
 Iterates read index.<br  />
 If a string is detected, all calls will be disabled until a new character is received.<br  />
 <br  />
 Shift parameter detects substring offset by shift places. Useful for detecting a command with parameter (i.e. "c_25").<br  />
 Moves the receive buffer pointer back to the end of the substring if move_pointer is set to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>char array to be detected </td></tr>
    <tr><td class="paramname">shift</td><td>offset of string from end of receive buffer (default = 0) </td></tr>
    <tr><td class="paramname">move_pointer</td><td>moves rd_index to end of detected string if shift is on (default = true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if string has been received </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Input array must be null-character terminated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#afa7345066fbeeecdfc6320af05c95838" title="Receive character across USB from host.">Receive()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a1f742c399f9ad7bcc5719b9aa8a24ff0" title="Checks if input string followed by an ASCII parameter has been received across USB from host and retu...">ReceiveParam()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#ab3e39a9bf73b5134ff0eb72b36b218f8" title="Receives ASCII number across USB from host and returns unsigned int.">ReceiveInt()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_serial_u_s_b_1_1_u_s_b_controller_a8e3331f2f23514b6980ef07623f3674b_cgraph.png" border="0" usemap="#aclass_serial_u_s_b_1_1_u_s_b_controller_a8e3331f2f23514b6980ef07623f3674b_cgraph" alt=""/></div>
<map name="aclass_serial_u_s_b_1_1_u_s_b_controller_a8e3331f2f23514b6980ef07623f3674b_cgraph" id="aclass_serial_u_s_b_1_1_u_s_b_controller_a8e3331f2f23514b6980ef07623f3674b_cgraph">
<area shape="rect" title="Checks if input string has been received over USB from host." alt="" coords="5,5,191,47"/>
<area shape="rect" href="namespace_serial.html#a765e3d30c8e412dd3eb1627312b3d4de" title="Blank Interrupt Enable function to be used as blank parameter for implementing serial buffer." alt="" coords="239,13,385,39"/>
</map>
</div>

</div>
</div>
<a id="aae7e36dd99bc47027609623f39ec467a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7e36dd99bc47027609623f39ec467a">&#9670;&nbsp;</a></span>ResetBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialUSB::USBController::ResetBuffer </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets FIFO receive buffer. </p>
<p>Resets USB controller buffer using parameters for initialized arrays.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>initialized character array used for FIFO receive buffer </td></tr>
    <tr><td class="paramname">buf_size</td><td>buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a14b3b3f5b75c8409ac7c31ae99a9c86b" title="Initializes USB serial communication.">Init()</a> </dd></dl>

</div>
</div>
<a id="a5802a3f2aebbf57800b613339a66f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5802a3f2aebbf57800b613339a66f84b">&#9670;&nbsp;</a></span>Task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SerialUSB::USBController::Task </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>echo</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB Task Routine. </p>
<p>Function to be called in main while loop before or after application code. This will read all incoming data into the FIFO receive buffer and echo read data if desired using optional parameters. This also performs the main tusb task. There is also an option to disable the FIFO receive buffer which will not allow any read data to fill the FIFO receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">echo</td><td>sends all received data back to the host device allowing it to be read on a terminal (default = false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#af3721932b0112fe15c43a969a06d1144" title="USB Interrupt Service Routine.">ISR()</a> </dd></dl>

</div>
</div>
<a id="a016f4dfe9a3fd5185d1eb38330a3d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016f4dfe9a3fd5185d1eb38330a3d950">&#9670;&nbsp;</a></span>Transmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::Transmit </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit character across USB. </p>
<p>Uses tusb FIFO queue to transmit a character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>char to be transmitted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of transmission </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a808ce3f51a820009b04e46cba483de4e" title="Transmits a packet of bytes, which do not need to be null-terminated.">TransmitPacket()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#aea4ae218bf10826e4943b542d782695c" title="Transmit string across USB.">TransmitString()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a41534109837d3f7557049e6d67fdfac0" title="Transmits unsigned int as ASCII string over USB.">TransmitInt()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>

</div>
</div>
<a id="a41534109837d3f7557049e6d67fdfac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41534109837d3f7557049e6d67fdfac0">&#9670;&nbsp;</a></span>TransmitInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::TransmitInt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits unsigned int as ASCII string over USB. </p>
<p>Transmits each digit as an ASCII string using tusb FIFO queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>raw value of integer to be transmitted as ASCII characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of transmission </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a016f4dfe9a3fd5185d1eb38330a3d950" title="Transmit character across USB.">Transmit()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a808ce3f51a820009b04e46cba483de4e" title="Transmits a packet of bytes, which do not need to be null-terminated.">TransmitPacket()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#aea4ae218bf10826e4943b542d782695c" title="Transmit string across USB.">TransmitString()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="class_serial_u_s_b_1_1_u_s_b_controller_a41534109837d3f7557049e6d67fdfac0_cgraph.png" border="0" usemap="#aclass_serial_u_s_b_1_1_u_s_b_controller_a41534109837d3f7557049e6d67fdfac0_cgraph" alt=""/></div>
<map name="aclass_serial_u_s_b_1_1_u_s_b_controller_a41534109837d3f7557049e6d67fdfac0_cgraph" id="aclass_serial_u_s_b_1_1_u_s_b_controller_a41534109837d3f7557049e6d67fdfac0_cgraph">
<area shape="rect" title="Transmits unsigned int as ASCII string over USB." alt="" coords="5,5,191,47"/>
<area shape="rect" href="namespace_serial.html#af0ab7fa07a594bbdcd2ae081e4b1229e" title="Integer to ASCII helper function." alt="" coords="239,13,365,39"/>
</map>
</div>

</div>
</div>
<a id="a808ce3f51a820009b04e46cba483de4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808ce3f51a820009b04e46cba483de4e">&#9670;&nbsp;</a></span>TransmitPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SerialUSB::USBController::TransmitPacket </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a packet of bytes, which do not need to be null-terminated. </p>
<p>Transmits an array of characters given the number of characters to transmit. Good for sending raw bytes rather than ASCII characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>char array to be sent to host </td></tr>
    <tr><td class="paramname">num_bytes</td><td>number of bytes to be sent to host </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success of transmission </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a016f4dfe9a3fd5185d1eb38330a3d950" title="Transmit character across USB.">Transmit()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#aea4ae218bf10826e4943b542d782695c" title="Transmit string across USB.">TransmitString()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a41534109837d3f7557049e6d67fdfac0" title="Transmits unsigned int as ASCII string over USB.">TransmitInt()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>

</div>
</div>
<a id="aea4ae218bf10826e4943b542d782695c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4ae218bf10826e4943b542d782695c">&#9670;&nbsp;</a></span>TransmitString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SerialUSB::USBController::TransmitString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmit string across USB. </p>
<p>Uses tusb FIFO queue to transmit an entire array of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>char array to be sent to host </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes sent in transmission </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Input array must be null-terminated. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a016f4dfe9a3fd5185d1eb38330a3d950" title="Transmit character across USB.">Transmit()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a808ce3f51a820009b04e46cba483de4e" title="Transmits a packet of bytes, which do not need to be null-terminated.">TransmitPacket()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a41534109837d3f7557049e6d67fdfac0" title="Transmits unsigned int as ASCII string over USB.">TransmitInt()</a>, <a class="el" href="class_serial_u_s_b_1_1_u_s_b_controller.html#a5802a3f2aebbf57800b613339a66f84b" title="USB Task Routine.">Task()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>SerialLibraryExample/serial_controllers/serial_usb/<a class="el" href="serial__usb_8h_source.html">serial_usb.h</a></li>
<li>SerialLibraryExample/serial_controllers/serial_usb/serial_usb.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
